java.util.Collection 是一个集合接口，Set 和List 都继承了Conllection,Map没有。
java.util.Collections 是一个类。它包含有静态多态方法。此类不能实例化。

------------------------- Set -------------------------------
HashSet : 为快速查找设计的Set。存入HashSet的对象必须定义hashCode()。就是使用对象的hashCode()进行快速查询的。此方法能够显着提高性能。
TreeSet : 保存次序的Set, 底层为树结构。可以实现排序等功能的集合，它在讲对象元素添加到集合中时会自动按照某种比较规则将其插入到有序的对象序列中，并保证该集合
          元素按照“升序”排列。
LinkedHashSet : 具有HashSet的查询速度，且内部使用链表维护元素的顺序(插入的次序)。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示。

------------------------- List -------------------------------
ArrayList() : 代表长度可以改变得数组。可以对元素进行随机的访问，向ArrayList()中插入与与删除元素的速度慢。
LinkedList(): 在实现中采用链表数据结构。插入和删除速度快，访问速度慢。对于List的随机访问来说，就是只随机来检索位于特定位置的元素。

------------------------- Map -------------------------------
HashMap : Map基于散列表的实现。插入和查询“键值对”的开销是固定的。可以通过构造器设置容量capacity和负载因子load factor（0.75，当元素个数超过容量长度的0.75倍时
	  ，进行扩容），以调整容器的性能。
LinkedHashMap : 使用链表维护内部次序。
TreeMap : 基于红黑树数据结构的实现。

--------------------------- Java 常用List集合使用场景分析 ---------------------
ArrayList : 基于数组实现的非线程安全的集合，查询数据快，是因为数组可以通过下标直接找到元素。 
            每次从中间插入和删除元素都会进行复制数组的操作，如果频繁操作，是比较消耗性能的，从末尾添加删除元素没影响。
LinkedList : 基于链表实现的非线程安全的集合。查询是通过遍历链表找，插入和删除只是指针指向修改，比较快。
Vector : 底层通过synchronized修饰，从而实现线程安全的效果。当并发量增多，锁竞争的问题严重，会导致性能下降。
CopyOnWriteArrayList : 底层通过ReentrantLock加锁的方式实现线程安全的效果。相对于synchronized，有更好的锁投票机制，能在激烈的锁竞争问题上表现更佳的性能。

https://pan.baidu.com/share/init?surl=_n8pos-hW1BFkpxjqI6bbQ