每周10道Java面试题 -- https://www.cnblogs.com/gxq666/p/9933020.html

每周10道Java面试题：集合类 - http://www.importnew.com/31126.html
每周10道Java面试题：String, String Pool, StringBuilder - http://www.importnew.com/31022.html
String 类和常量池 - http://www.importnew.com/31126.html

String类为什么用final修饰符
  主要是为了”安全性“和”效率“的缘故
  安全 -- 如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，因为字符串是不可变的，所以它的值是不可改变的，
          否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞
       -- String类调用系统API，那么如果这种类可以被继承的话，如果我们再把它的方法重写了，往操作系统内部写入一段具有恶意攻击性质的代码什么的，这不就成了核心病毒了么？
  final修饰的类不可以被继承，那么也就是说如果有一个String的引用，它引用的一定是一个String对象，而不可能是其他类的对象。 
  final修饰的方法不能被重写
  final修饰的变量，无论是类属性、对象属性、形参还是局部变量，都需要进行初始化操作

  String不可变很简单，给一个已有字符串"abcd"第二次赋值成"abcedl"，不是在原内存地址上修改数据，而是重新指向一个新对象，新地址。

接口和抽象类的区别
  抽象类可以有默认的方法实现	                        java 8之前,接口中不存在方法的实现.
  抽象类中可以有构造器					接口中不能
  抽象方法可以有public,protected和default等修饰		接口默认是public,不能使用其他修饰符
  一个子类只能存在一个父类				一个子类可以存在多个接口

父类的静态方法能否被子类重写
  不能。重写只适用于实例方法,不能用于静态方法，而子类当中含有和父类相同签名的静态方法，我们一般称之为隐藏。

switch中能否使用string做参数
  从idk 1.7之后switch开始支持String。

String s1=”ab”, String s2=”a”+”b”, String s3=”a”, String s4=”b”, s5=s3+s4请问s5==s2返回什么？
  返回false。在编译过程中，编译器会将s2直接优化为”ab”，会将其放置在常量池当中，s5则是被创建在堆区，相当于s5=new String(“ab”);
  
堆和栈的区别
  JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈
  当new一个对象时
  堆：在堆中分配实际内存建立这个对象。由JVM动态分配内存空间。一个JVM只有一个堆内存，线程是可以共享数据的。
  栈：分配的内存只是一个指向这个堆对象的引用而已，每个线程都会有一个独立的栈空间，所以线程之间是不共享数据的。
  异常错误
    如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。
    而如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。

==和equals
  "=="是判断两个变量或实例是不是指向同一个内存空间。
  "equals"是判断两个变量或实例所指向的内存空间的值是不是相同。

a=a+b与a+=b有什么区别吗?
  +=操作符会进行隐式自动类型转换，此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型，而a=a+b则不会自动进行类型转换

final, finalize和finally的不同之处
  final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。finalize 方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，
  但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和+ catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。

深拷贝和浅拷贝的区别是什么?
  浅拷贝：拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。
  深拷贝：深拷贝把要复制的对象所引用的对象都复制了一遍。

int和Integer的区别
  Integer是int的包装类型，在拆箱和装箱中，二者自动转换。int是基本类型，直接存数值，而integer是对象，用一个引用指向这个对象。

StringBuffer和StringBuilder
  StringBuffer是线程安全的可变字符串，其内部实现是可变数组。StringBuilder是jdk 1.5新增的，其功能和StringBuffer类似，但是非线程安全。因此，在没有多线程问题的前提下，使用StringBuilder会取得更好的性能。

说说进程，线程，协程之间的区别
  进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。
  线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。

你了解守护线程吗？它和非守护线程有什么区别
  程序运行完毕，jvm会等待非守护线程完成后关闭，但是jvm不会等待守护线程。守护线程最典型的例子就是GC线程。

什么是多线程上下文切换
  多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。

创建两种线程的方式?他们有什么区别?
  通过实现java.lang.Runnable或者通过扩展java.lang.Thread类。相比扩展Thread，实现Runnable接口可能更优.原因有二：
  Java不支持多继承。因此扩展Thread类就代表这个子类不能扩展其他类。而实现Runnable接口的类还可能扩展另一个类。
  类可能只要求可执行即可，因此继承整个Thread类的开销过大。

Thread类中的start()和run()方法有什么区别?
  start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法
  才会启动新线程。

wait()与sleep()的区别
  sleep()来自Thread类，和wait()来自Object类。调用sleep()方法的过程中，线程不会释放对象锁。而调用wait()方法线程会释放对象锁
  sleep()睡眠后不出让系统资源，wait让其他线程可以占用CPU
  sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒.而wait()需要配合notify()或者notifyAll()使用
  也可见代码

一个线程如果出现了运行时异常怎么办?
  如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放

为什么要使用线程池
  避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。

java中用到的线程调度算法是什么
  抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。

Thread.sleep(0)的作用是什么
  由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，
  这也是平衡CPU控制权的一种操作。

什么是CAS
  CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。
  当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。

什么是乐观锁和悲观锁
  乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。
  悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。

ConcurrentHashMap的工作原理
  ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表->红黑树”的实现。

你有哪些多线程开发良好的实践?
  给线程命名
  最小化同步范围
  优先使用volatile
  尽可能使用更高层次的并发工具而非wait和notify()来实现线程通信,如BlockingQueue,Semeaphore
  优先使用并发容器而非同步容器.
  考虑使用线程池

LinkedHashMap和PriorityQueue的区别
  PriorityQueue 是一个优先级队列,保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。
  当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。

WeakHashMap与HashMap的区别是什么?
  WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。

ArrayList和LinkedList的区别?
  最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。

ArrayList和Array有什么区别?
  Array可以容纳基本类型和对象，而ArrayList只能容纳对象。
  Array是指定大小的，而ArrayList大小是固定的

mysql null与空的区别
  1.null占用空间，而空不占用
  2.在进行count()统计某列的记录数的时候，不会统计列值为null的。
  3.<>会过滤空和null的
  4.对于MySQL特殊的注意事项，对于timestamp数据类型，如果往这个数据类型插入的列插入NULL值，则出现的值是当前系统时间。插入空值，则会出现 ‘0000-00-00 00:00:00’ 

修饰符public,private,protected,以及不写时的区别
修饰符	     当前类	同一package	子孙类	其他package
public	        √	   √	        √	√
protected	√	   √		√	×
default	        √	   √		×	×       
private	        √	   ×		×	×

String s = new String("xyz");创建了几个String Object
一个字符对象，一个字符对象引用对象

Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型
Overloaded的方法是可以改变返回值的类型

-- 接口是否可继承接口
接口可以继承接口。
抽象类可以实现接口，
抽象类可继承实体类，但前提是实体类必须有明确的构造函数

