spring是一个开源的IOC和AOP容器框架，可以集成其他框架

1.org.springframework.beans.factory.BeanFactory 
  -- 这个是spring容器的顶层接口，提供了容器最基本的功能
2.org.springframework.context.ApplicationContext 
  -- 继承了BeanFactory接口，并且在其上进行了扩展，增加了很多功能，比如AOP、国际化、事件支持等等。。
3.org.springframework.context.support.ClassPathXmlApplicationContext 
  -- 这个类实现了ApplicationContext接口，这个容器类可以从classpath中加载bean xml配置文件，然后创建xml中配置的bean对象
4.org.springframework.context.annotation.AnnotationConfigApplicationContext
  -- 这个类实现了ApplicationContext接口，bean的定义支持xml的方式和注解的方式，当我们使用注解的方式定义bean的时候，就需要用到这个容器来装载了

引用 spring-core、spring-context、spring-beans 包

bean.xml -- <bean id="helloWorld" class="com.javacode2018.lesson001.demo1.HelloWorld"/>

public class Client {
    public static void main(String[] args) {
        String beanXml = "classpath:/com/javacode2018/lesson001/demo1/beans.xml";
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(beanXml);
        HelloWorld helloWorld = context.getBean("helloWorld", HelloWorld.class);
        helloWorld.say();
    }
}

Spring容器内部创建bean实例对象常见的有4种方式：
1.调用类的构造方法获取对应的bean实例，是使用最多的方式，这种方式只需要在xml bean元素中指定class属性，spring容器内部会自动调用该类型的构造方法来创建bean对象，将其放在容器中以供使用
2.通过静态工厂方法创建bean对象
<bean id="bean名称" name="" class="静态工厂完整类名" factory-method="静态工厂的方法"> -- 返回需要的类型对象
    <constructor-arg index="0" value="bean的值" ref="引用的bean名称" /> -- 构造函数第0个参数
    <constructor-arg index="1" value="bean的值" ref="引用的bean名称" />
    <constructor-arg index="2" value="bean的值" ref="引用的bean名称" />
</bean>

@Scope注解 作用域
bean的生命周期
容器启动 - 实例化 - 数据装配 - 初始化（init） - 使用 - 销毁
<bean id="singletonBean" class="com.javacode2018.lesson001.demo4.BeanScopeModel" scope="singleton">
    <constructor-arg index="0" value="singleton"/>
</bean> -- 实例在容器启动过程中就创建好了
prototype -- 每次获取都会重新创建一个bean实例对象，每次获取的时候才会去调用构造方法创建bean实例
request 同一个请求单例
session 同一个会话单例

单例中bean的属性是线程不安全的，比如controller中的private name，经由两个controller赋值，视频中说这个属性是全局属性，如果是方法中的变量则不是全局的

springmvc中controller默认是单例的

@Autowired(required=false) -- 如果不配置Bean会抛异常，这样就不错了，认为这两个属性为null
@Qualifier("bmwCar") 如果一个接口有多个实现类，这样可以指定实现类

@Configuration把一个类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。

@Lazy(true) 表示延迟初始化

@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常
@Async异步方法调用

-- 代理知识
https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ%3D%3D&chksm=88621efcbf1597eab943b064147b8fb8fd3dfbac0dc03f41d15d477ef94b60d4e8f78c66b262&idx=1&lang=zh_CN&mid=2648934082&scene=21&sn=c919886400135a0152da23eaa1f276c7&token=1042984313#wechat_redirect


ApplicationContextHolder - 实现ApplicationContextAware接口，用于保证全局只有一个Ioc容器

xxxFactoryBean（实现FactoryBean接口） - 一般这个名字的，取到的都不是这个本类的实例，而是他其中getObject中返回的实例

ehcacheManager.setCacheManagerConfigFile("classpath:ehcache-shiro.xml"); -- 类路径下
ehcacheManager.setCacheManagerConfigFile("file:c:/ehcache-shiro.xml"); -- 文件路径

@Autowired - 默认按类型装配，如果有多个，按ByName
@Value - 通过属性注入，不用写set get

@ModelAttribute 自定义的参数模型默认加这个标签
@sessionAttribute("user") - 说是把request作用域参数放在session里

BeanPostProcessor是Spring IOC容器给我们提供的一个扩展接口。接口声明如下：

===Spring IOC容器实例化Bean===
===调用BeanPostProcessor的postProcessBeforeInitialization方法===
===调用bean实例的初始化方法===
===调用BeanPostProcessor的postProcessAfterInitialization方法===

Spring事务的种类：
spring支持编程式事务管理和声明式事务管理两种方式：
编程式事务管理使用TransactionTemplate。
声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，
在执行完目标方法之后根据执行情况提交或者回滚事务。

声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中。

声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式，使业务代码不受污染，只要加上注解就可以获得完全的事务支持。唯一不足地方是，
最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。
（2）spring的事务传播行为：
spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。
PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。
PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。
PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。
PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。
PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。
PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。
（3）Spring中的隔离级别：
ISOLATION_DEFAULT：这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。
ISOLATION_READ_UNCOMMITTED：读未提交，允许另外一个事务可以看到这个事务未提交的数据。
ISOLATION_READ_COMMITTED： 读已提交，保证一个事务修改的数据提交后才能被另一事务读取，而且  能看到该事务对已有记录的更新。
ISOLATION_REPEATABLE_READ：可重复读，保证一个事务修改的数据提交后才能被另一事务读取，但是不能看到该事务对已有记录的更新。
ISOLATION_SERIALIZABLE：一个事务在执行的过程中完全看不到其他事务对数据库所做的更新。
