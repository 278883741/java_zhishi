CREATE TABLE `equip` (
  `id` int(11) unsigned NOT NULL COMMENT  '接口中值的id' AUTO_INCREMENT,
  `rune_id` int(11) DEFAULT NULL COMMENT 'rune_id',
  `name` varchar(128) DEFAULT NULL COMMENT '',
  `category` varchar(128) DEFAULT NULL COMMENT '例值：gongji',
  `tier` varchar(128) NULL DEFAULT NULL COMMENT '',
  `icon` varchar(128) NULL DEFAULT NULL COMMENT '头像',
  `price` int(11) NULL DEFAULT NULL COMMENT '',
  `detail` varchar(128) NULL DEFAULT NULL COMMENT '',
  `parent_id` varchar(128) NULL DEFAULT NULL COMMENT '',
  `child_id` varchar(128) NULL DEFAULT NULL COMMENT '',
  `suit` varchar(128) NULL DEFAULT NULL COMMENT '',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COMMENT='系统访问日志';

alter table rune_attribute change value param_value VARCHAR(128)

https://www.cnblogs.com/softidea/p/5977860.html -- 索引

================================= 索引 ===========================================
CREATE INDEX index_name ON table_name (column_list);
CREATE UNIQUE INDEX index_name ON table_name (column_list);

不能用CREATE INDEX语句创建PRIMARY KEY索引。

-------- 联合唯一索引 ---------
create UNIQUE index uk_student_no on channel_student_info(student_no,delete_status);

其实在联合索引上会有一个mysql索引最左匹配原则，但是如果联合索引的第一个列不在where条件语句中，并且所查询的列其中有的是没有建立索引的，那么这个联合索引就是无效的。
公司DBA也建议如果使用联合索引，那么where条件也要尽量根据联合索引的顺序来，如果不按照顺序来，索引也同样会用到，
但是在执行前，SQL优化器也会将条件调整为联合索引的顺序，既然可以直接避免这种情况，就没必要再让SQL优化器去处理，毕竟处理也是有开销的。

如果我们创建了(area, age,salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀特性。
因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。
---------------------------

DROP INDEX index_name ON talbe_name

ALTER TABLE 'table_name' ADD PRIMARY KEY('col')；-- 主键索引：即主索引，根据主键pk_clolum（length）建立索引，不允许重复，不允许空值；
ALTER TABLE 'table_name' ADD UNIQUE('col')；-- 唯一索引：不允许重复，允许空值
ALTER TABLE 'table_name' ADD INDEX index_name('col')；-- 普通索引,没有任何限制
ALTER TABLE 'table_name' ADD FULLTEXT('col')；-- 全文索引：用大文本对象的列构建的索引（下一部分会讲解）
ALTER TABLE 'table_name' ADD INDEX index_name('col1','col2','col3')；-- 组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值

--------------------------------------------------------------------------
show index from tblname;

Seq_in_index

　　索引中的列序列号，从1开始。

Collation

　　列以什么方式存储在索引中。在MySQL中，有值‘A’（升序）或NULL（无分类）。

Cardinality

　　索引中唯一值的数目的估计值。通过运行ANALYZE TABLE或myisamchk -a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL使用该索引的机会就越大。

Null

　　如果列含有NULL，则含有YES。如果没有，则该列含有NO。

 Index_type

　　用过的索引方法（【BTREE】, FULLTEXT, HASH, RTREE）。
--------------------------------------------------------------------------

Mysql的索引有哪几类？聚集索引和非聚集索引区别？（适用场景？）
MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，B+Tree索引，哈希索引，全文索引等等，
聚集索引的数据的物理存放顺序与索引顺序是一致的
非聚簇索引，记录的物理顺序与逻辑顺序没有必然的联系。非聚簇索引则更像书的标准索引表，索引表中的顺序通常与实际的页码顺序是不一致的。

------------------------------- 什么情况下应不建或少建索引 ------------------------------------
1.表记录太少 - 不会用你建的索引，而是自动执行全表访问
2.经常插入、删除、修改的表
3.数据重复且分布平均的表字段 - 假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。
4.经常和主字段一块查询但主字段索引值比较多的表字段 - 举的例子是根据电费号查询，再根据日期查询意义就不大了。
-----------------------------------------------------------------------------------------------

------------------------------------- MySql在建立索引优化时需要注意的问题 ------------------------
1.但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。
2.我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。(area, age,salary)。
3.只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。
4.mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。
5.一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。
6.不要在列上进行运算 - select * from users where YEAR(adddate)。
7.不使用NOT IN和操作，NOT IN可以NOT EXISTS代替。
--------------------------------------------------------------------------------------------------

--------------------------------------------- explain --------------------------------------------
此时我们可以借助mysql查询优化器explain，explain会纠正sql语句该以什么样的顺序(索引的最左匹配)执行效率最高，最后才生成真正的执行计划。
where后面只能走一个索引，如果走了where的，那么后面的order by就不回走索引了

深入理解MySQL索引原理和实现――为什么索引可以加速查询？
  索引是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据。
索引的优缺点
  优势：可以快速检索，减少I/O次数，加快检索速度；根据索引分组和排序，可以加快分组和排序
  劣势：索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的1.5倍；索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；
  构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表；
---------------------------------------------------------------------------------------------------
=======================================================================================================

=============================================== 事务 =================================================

------------------------------------------- 事务的原理 -------------------------------------------
在 MySQL 中，恢复机制是通过回滚日志（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。
回滚日志除了能够在发生错误或者用户执行ROLLBACK时提供回滚相关的信息，它还能够在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，
这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要先写日志后写数据库的主要原因。

回滚日志并不能将数据库物理地恢复到执行语句或者事务之前的样子；它是逻辑日志，当回滚日志被使用时，它只会按照日志逻辑地将数据库中的修改撤销掉看，可以理解为，我们在事务中使用的每一条 INSERT 都对应了一条 DELETE，
每一条 UPDATE 也都对应一条相反的 UPDATE 语句。

事务的状态也只有三种：Active、Commited 和 Failed
-------------------------------------------------------------------------------------

---------------------------------------- 慢查询 ---------------------------------------------
show variables like '%slow_query_log%'; - 是否开启慢查询
show variables like '%long_query_time%' - 慢查询阈值，默认是10s
show variables like '%log_queries_not_using_indexes%'; - 未使用索引的查询也被记录到慢查询日志中（可选项）
log_output：日志存储方式。log_output='FILE'表示将日志存入文件，默认值是'FILE'。log_output='TABLE'表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。MySQL数据<br>库支持同时两种日志存储方式，
	    配置的时候以逗号隔开即可，如：log_output='FILE,TABLE'。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需<br>要能够获得更高的系统性能，那么建议优先记录到文件。
log_slow_admin_statements - 表示是否将慢管理语句例如ANALYZE TABLE和ALTER TABLE等记入慢查询日志
https://www.cnblogs.com/saneri/p/6656161.html -- 慢查询
---------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
什么是存储引擎？mysql的常用存储引擎有哪些？各自的区别是什么？（适用场景？）
  MySQL5.5以后默认使用InnoDB存储引擎，其中InnoDB和BDB提供事务安全表，其它存储引擎都是非事务安全表。
  InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。

事务隔离级别有哪些？默认是哪种？
  事务的基本要素 - ACID
  原子性（Atomicity）:事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。
		      也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。
  一致性（Consistency）:事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。
  隔离性（Isolation）:同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。
  持久性（Durability）:事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。
  
  事务隔离级别
  读未提交（read-uncommitted）- 使用查询语句不会加锁，可能会读到未提交的行（Dirty Read）；
  不可重复读（read-committed）- 事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
  可重复读（repeatable-read）- 多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生幻读（Phantom Read）；
  串行化（serializable）- InnoDB 隐式地将全部的查询语句加上共享锁，解决了幻读的问题；
  默认的事务隔离级别为repeatable-read(不允许脏读和不可重复读)
    脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
    幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

事务的锁
  根据读写，分为共享锁S和排它锁X
  共享锁：即读加锁，不能写并且可并行读
  排它锁:写加锁，其他读写都阻塞
  表锁：锁整个表，性能开销最大，其他的读写都要挂起
  行锁：锁整个行，以默认隔离级别为例：如果是读，那么会上共享锁，不允许写，如果是写，那么该行其他事务无论读写都得阻塞
  

Mysql的日志文件有哪几类？存储sql命令的文件是什么？
  Error log ( 错误日志 )
  Binary log（ 二进制日志 ）
  Update log（ 更新日志 ）
  Query log（ 查询日志 ）
  Slow query log ( 慢查询日志 )
  Innodb redo log ( Innodb 的在线 redo 日志 )
  具体参考  https://www.cnblogs.com/wangxiaoqiangs/p/5383510.html
Mysql的事务是如何实现的？（原理？）
  https://blog.csdn.net/J_java1/article/details/82025189

============================ MySQL 性能优化的最佳20多条经验分享 =====================================
1.为查询缓存优化你的查询 

// 查询缓存不开启 
$r = mysql_query("SELECT username FROM user WHERE signup_date >= CURDATE()"); 

// 开启查询缓存 
$today = date("Y-m-d"); 
$r = mysql_query("SELECT username FROM user WHERE signup_date >= '$today'"); 

2.EXPLAIN 你的 SELECT 查询 
  使用 EXPLAIN 关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈，EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的。
  使用帮助:https://www.cnblogs.com/clphp/p/5403215.html

3.当只要一行数据时使用 LIMIT 1 
4.为搜索字段建索引 - 索引并不一定就是给主键或是唯一的字段。如果在你的表中，有某个字段你总要会经常用来做搜索，那么，请为其建立索引吧。
5.在Join表的时候使用相当类型的列，并将其索引。这样，MySQL内部会启动为你优化Join的SQL语句的机制。 
  而且，这些被用来Join的字段，应该是相同的类型的。例如：如果你要把 DECIMAL 字段和一个 INT 字段Join在一起，MySQL就无法使用它们的索引。
6.千万不要 ORDER BY RAND() - MySQL会不得不去执行RAND()函数（很耗CPU时间），而且这是为了每一行记录去记行，然后再对其排序。就算是你用了Limit 1也无济于事（因为要排序）
7.避免 SELECT * 
8.永远为每张表设置一个ID
9.使用 ENUM 而不是 VARCHAR 
  ENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。 
  如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。 
11. 尽可能的使用 NOT NULL 
12.垂直分割 - 拆表
   示例二：你有一个叫 “last_login” 的字段，它会在每次用户登录时被更新。但是，每次更新时会导致该表的查询缓存被清空。所以，你可以把这个字段放到另一个表中，这样就不会影响你对用户 ID，用户名，用户角色的不停地读取了，
	   因为查询缓存会帮你增加很多性能。 
   另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去Join他们，不然的话，这样的性能会比不分割时还要差，而且，会是极数级的下降。 
13. 拆分大的 DELETE 或 INSERT 语句
    如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。 
    Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。 
    如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你泊WEB服务Crash，还可能会让你的整台服务器马上炝恕 
    所以，如果你有一个大的处理，你定你一定把其拆分，使用 LIMIT 条件是一个好的方法。下面是一个示例：
19. 选择正确的存储引擎 
    在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。
    MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到写操作完成。 
    InnoDB 支持行锁，支持事务
=====================================================================================================



